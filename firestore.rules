rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAdmin() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isAdmin == true;
    }

    // Role-based access control functions
    function hasAdminRole(role) {
      // Get admin document and check role
      let adminDoc = get(/databases/$(database)/documents/admin_roles/$(request.auth.uid));
      return adminDoc.exists && adminDoc.data.role == role;
    }

    function isSuperAdmin() {
      return hasAdminRole('superAdmin');
    }

    function isModerator() {
      return hasAdminRole('moderator') || isSuperAdmin();
    }

    function isAnalyst() {
      return hasAdminRole('analyst') || isSuperAdmin();
    }

    function isFinancialAdmin() {
      return hasAdminRole('financial') || isSuperAdmin();
    }

    function isSupportAdmin() {
      return hasAdminRole('support') || isSuperAdmin();
    }
    
    function isApprovedCompany() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isApproved == true &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isCompany == true;
    }

    function isTrainer() {
      return isAuthenticated() && (
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.accountType == 'trainer' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.userType == 'trainer' ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isTrainer == true ||
        get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isMentor == true
      );
    }

    function hasKycDoc(docKey) {
      return request.resource.data.documents is map &&
             request.resource.data.documents[docKey] is map &&
             request.resource.data.documents[docKey].url is string &&
             request.resource.data.documents[docKey].url.size() > 0;
    }

    function isValidKycSubmission() {
      // Only check for the required documents that are actually needed
      return hasKycDoc('cipa_certificate') &&
             hasKycDoc('cipa_extract') &&
             hasKycDoc('burs_tin') &&
             hasKycDoc('proof_of_address');
    }
    
    function isCompany() {
      return isAuthenticated() && 
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isCompany == true;
    }
    
    // Helper function to validate rating creation
    function canCreateRating() {
      // Must be authenticated and raterId must match current user
      return isAuthenticated() && 
             request.resource.data.raterId == request.auth.uid &&
             // Required fields validation
             request.resource.data.keys().hasAll(['raterId', 'ratedUserId', 'rating', 'jobId']) &&
             // Rating must be between 0 and 5 (accepts both int and float)
             (request.resource.data.rating is float || request.resource.data.rating is int) &&
             request.resource.data.rating >= 0.0 &&
             request.resource.data.rating <= 5.0 &&
             // Validate rater and rated user types
             request.resource.data.raterType in ['company', 'jobSeeker'] &&
             request.resource.data.ratedUserType in ['jobSeeker', 'company'] &&
             // Get the job document to validate relationship
             get(/databases/$(database)/documents/jobs/$(request.resource.data.jobId)).exists &&
             // Job must be completed (status = 'filled')
             get(/databases/$(database)/documents/jobs/$(request.resource.data.jobId)).data.status == 'filled' &&
             // Ratings are visible immediately - isApproved must be true
             request.resource.data.isApproved == true &&
             // Ratings must not be flagged when created
             ( ! (request.resource.data.keys().hasAny(['isFlagged']) ) || request.resource.data.isFlagged == false ) &&
             // Prevent duplicate ratings: client must use deterministic rating doc id
             // (the match /ratings/{ratingId} will enforce id format)
             // Validate based on rater type
             (
               // Job seeker rating company: job seeker must be in hiredApplicants AND company is job owner
               (request.resource.data.raterType == 'jobSeeker' &&
                request.auth.uid in get(/databases/$(database)/documents/jobs/$(request.resource.data.jobId)).data.hiredApplicants &&
                request.resource.data.ratedUserId == get(/databases/$(database)/documents/jobs/$(request.resource.data.jobId)).data.userId) ||
               // Company rating job seeker: company owns job AND job seeker is in hiredApplicants
               (request.resource.data.raterType == 'company' &&
                request.auth.uid == get(/databases/$(database)/documents/jobs/$(request.resource.data.jobId)).data.userId &&
                request.resource.data.ratedUserId in get(/databases/$(database)/documents/jobs/$(request.resource.data.jobId)).data.hiredApplicants)
             );
    }
    
    // Users collection
    match /users/{userId} {
      // Anyone authenticated can read user profiles
      allow read: if isAuthenticated();
      
      // Users can create their own profile
      allow create: if isOwner(userId) &&
                      request.resource.data.keys().hasAll(['email', 'name']) &&
                      request.resource.data.email == request.auth.token.email;
      
      // Users can update their own profile, admins can update any profile
      // Additionally allow authenticated callers to update only rating aggregation
      // fields (`rating` and `rating_count`) when they increment the count by 1.
      allow update: if isOwner(userId) || isAdmin() || (
        isAuthenticated() &&
        // Only the two aggregate fields may be modified in this path
        request.resource.data.keys().hasOnly(['rating', 'rating_count']) &&
        // rating must be numeric between 0 and 5
        (request.resource.data.rating is float || request.resource.data.rating is int) &&
        request.resource.data.rating >= 0.0 && request.resource.data.rating <= 5.0 &&
        // rating_count must be an integer and must increment previous count by 1
        (request.resource.data.rating_count is int) &&
        (request.resource.data.rating_count == ((resource.data.rating_count is int) ? resource.data.rating_count + 1 : 1))
      );
      
      // Only admins can delete users
      allow delete: if isAdmin();
      
      // Saved jobs subcollection
      match /saved_jobs/{jobId} {
        // Users can read and write their own saved jobs
        allow read, write: if isOwner(userId);
        // Admins can read any saved jobs
        allow read: if isAdmin();
      }
    }

    // Company KYC (verification documents/metadata)
    match /company_kyc/{companyId} {
      allow read: if isOwner(companyId) || isAdmin();
      
      // Company can create its own KYC document
      allow create: if isCompany() && 
                      isOwner(companyId) &&
                      (
                        request.resource.data.status == 'draft' ||
                        (request.resource.data.status == 'submitted' && isValidKycSubmission())
                      );

      allow update: if (
        // Admin can do anything
        isAdmin() ||
        // Company can update their own KYC
        (
          isCompany() &&
          isOwner(companyId) &&
          // Allow updates if status is draft or rejected (can resubmit)
          (resource == null || resource.data.status in ['draft', 'rejected'] || !resource.exists) &&
          // Can change to submitted if all required docs are present
          (
            request.resource.data.status != 'submitted' ||
            isValidKycSubmission()
          ) &&
          // Cannot set status to approved/rejected (only admin can)
          !(request.resource.data.status in ['approved'])
        )
      );
      allow delete: if isAdmin();
    }

    // User AI subcollections (signals/analysis)
    match /users/{userId}/ai/{docId=**} {
      allow read, write: if isOwner(userId) || isAdmin();
    }
    
    // Jobs collection
    match /jobs/{jobId} {
      // Anyone can read active jobs
      allow read: if true;
      
      // Authenticated users can create jobs (companies must be approved, all jobs require admin approval)
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.keys().hasAll(['title', 'description', 'userId', 'status']) &&
                      request.resource.data.status == 'pending' && // All jobs start as pending for admin approval
                      request.resource.data.isVerified == false &&
                      request.resource.data.isApproved == false &&
                      request.resource.data.approvalStatus == 'pending' &&
                      // Companies must be approved to post
                      (!(get(/databases/$(database)/documents/users/$(request.auth.uid)).data.isCompany == true) ||
                        isApprovedCompany());

      // Job owner or admin can update (but cannot directly modify hired/positions fields - must use client-side atomic transaction)
      // CRITICAL: hiredApplicants updates must be atomic with positionsFilled and must validate:
      //  - new applicant is in applications with status='accepted'
      //  - positionsFilled + increment <= positions
      //  - only job owner can make these updates
      // Additionally, allow authenticated users to perform limited updates related to applying (applicantsList and applicants count)
      allow update: if (
        (
          ((isAuthenticated() && resource.data.userId == request.auth.uid) || isAdmin()) &&
          // Prevent direct client updates to hiring-related fields - only Cloud Function can modify these except applicants/applicantsList
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['positionsFilled', 'hiredApplicants']) ||
           request.auth.token.firebase.sign_in_provider == 'custom')
        )
        ||
        (
          // Allow authenticated users to update only applicants/applicantsList (to support client-side application transaction)
          isAuthenticated() &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['applicantsList', 'applicants'])
        )
      );
      
      // Job owner or admin can delete
      allow delete: if (isAuthenticated() && resource.data.userId == request.auth.uid) || isAdmin();
    }

    // Legacy jobs collection used by some UI widgets
    match /jobPosted/{jobId} {
      allow read: if true;
      allow create: if isApprovedCompany() && request.resource.data.id == request.auth.uid;
      allow update, delete: if isAuthenticated() && resource.data.id == request.auth.uid || isAdmin();
    }
    
    // Applications collection
    match /applications/{applicationId} {
      // Users can read their own applications, job owners can read applications to their jobs
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || 
                     (resource.data.jobId != null && 
                      exists(/databases/$(database)/documents/jobs/$(resource.data.jobId)) &&
                      get(/databases/$(database)/documents/jobs/$(resource.data.jobId)).data.userId == request.auth.uid) ||
                     isAdmin());
      
      // Authenticated users can create applications
      // IMPORTANT: Job existence is validated here to prevent orphaned applications
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.keys().hasAll(['userId', 'jobId', 'status']) &&
                      request.resource.data.status == 'pending' &&
                      exists(/databases/$(database)/documents/jobs/$(request.resource.data.jobId));
      
      // Application owner or job owner can update
      allow update: if isAuthenticated() && 
                      (resource.data.userId == request.auth.uid || 
                       (resource.data.jobId != null && 
                        exists(/databases/$(database)/documents/jobs/$(resource.data.jobId)) &&
                        get(/databases/$(database)/documents/jobs/$(resource.data.jobId)).data.userId == request.auth.uid) ||
                       isAdmin());
      
      // Only application owner can delete their own application
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // CVs are used for employer candidate discovery and user profile building
    match /cvs/{cvId} {
      allow read: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.user_id == request.auth.uid ||
        isApprovedCompany() ||
        isAdmin()
      );
      allow create, update: if isAuthenticated() && (
        request.resource.data.userId == request.auth.uid ||
        request.resource.data.user_id == request.auth.uid
      );
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        resource.data.user_id == request.auth.uid
      );
    }
    
    // Interviews collection
    match /interviews/{interviewId} {
      // Candidate or employer can read
      allow read: if isAuthenticated() && 
                    (resource.data.candidate_id == request.auth.uid || 
                     resource.data.employer_id == request.auth.uid ||
                     isAdmin());
      
      // FIX 3: Only employers can create interviews - MUST have applicationId to link records
      // PROBLEM: Interview created without link to application record
      // SOLUTION: Firestore rules enforce application_id is required
      allow create: if isAuthenticated() &&
                      request.resource.data.employer_id == request.auth.uid &&
                      request.resource.data.keys().hasAll(['candidate_id', 'employer_id', 'scheduled_date', 'application_id']) &&
                      request.resource.data.application_id is string &&
                      request.resource.data.application_id.size() > 0;
      
      // Candidate or employer can update (for status changes, notes, etc.)
      allow update: if isAuthenticated() && 
                      (resource.data.candidate_id == request.auth.uid || 
                       resource.data.employer_id == request.auth.uid ||
                       isAdmin());
      
      // Only employer can delete
      allow delete: if isAuthenticated() && resource.data.employer_id == request.auth.uid;
    }

    // In-app notifications
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      // Only create notifications for oneself (no one can send notifications to others)
      // System notifications must be created server-side (admin-only)
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.keys().hasAll(['userId', 'type', 'title', 'body', 'isRead']);
      allow update, delete: if (isAuthenticated() && resource.data.userId == request.auth.uid) || isAdmin();
    }

    // Saved searches (per-user)
    match /saved_searches/{savedSearchId} {
      allow read: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
      allow create: if isAuthenticated() && (request.resource.data.userId == request.auth.uid || isAdmin());
      allow update, delete: if isAuthenticated() && resource.data.userId == request.auth.uid || isAdmin();
    }

    // Wallets
    match /wallets/{userId} {
      allow read: if isOwner(userId) || isAdmin();
      allow write: if isAdmin();
    }

    // Transactions
    match /transactions/{transactionId} {
      allow read: if isOwner(resource.data.userId) || isAdmin();
      allow create: if isAuthenticated() && 
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.type == 'deposit';
      allow update: if isAdmin();
      allow delete: if isAdmin();
    }

    // Chats
    match /chats/{chatId} {
      allow read: if isAuthenticated() && request.auth.uid in resource.data.participants;
      allow create: if isAuthenticated() && request.auth.uid in request.resource.data.participants;
      allow update: if isAuthenticated() && request.auth.uid in resource.data.participants;
      
      // Messages subcollection
      match /messages/{messageId} {
        allow read: if isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
        allow create: if isAuthenticated() && 
                        request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants &&
                        request.resource.data.senderId == request.auth.uid;
        allow update: if isAuthenticated() && 
                        request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants &&
                        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']));
        allow delete: if isAdmin();
      }
    }

    // System / Monetization Settings
    match /system/monetization {
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Trainer content
    match /courses/{courseId} {
      // Anyone can read approved/published courses
      allow read: if isAuthenticated() && (
        resource.data.status == 'approved' ||
        resource.data.status == 'published' ||
        resource.data.trainerId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // Both trainers and regular users (companies/job seekers) can create courses
      allow create: if isAuthenticated() &&
                      request.resource.data.keys().hasAll(['title', 'description']) &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.approvalStatus == 'pending' &&
                      request.resource.data.isApproved == false &&
                      request.resource.data.isVerified == false &&
                      (request.resource.data.trainerId == request.auth.uid ||
                       request.resource.data.userId == request.auth.uid ||
                       request.resource.data.creatorId == request.auth.uid);
      allow update, delete: if isAuthenticated() && (
        resource.data.trainerId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        resource.data.creatorId == request.auth.uid ||
        isAdmin()
      );
    }

    match /live_sessions/{sessionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && isTrainer() && request.resource.data.trainerId == request.auth.uid;
      allow update, delete: if isAuthenticated() && (
        resource.data.trainerId == request.auth.uid || isAdmin()
      );
    }
    
    // Comments collection (if used)
    match /comments/{commentId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
    }

    // Gigs collection (freelance gigs)
    match /gigs/{gigId} {
      // Anyone authenticated can read active/approved gigs
      allow read: if isAuthenticated() && (
        resource.data.status == 'active' ||
        resource.data.approvalStatus == 'approved' ||
        resource.data.freelancerId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // ANY authenticated user can create gigs (pending approval)
      allow create: if isAuthenticated() &&
                      (request.resource.data.freelancerId == request.auth.uid ||
                       request.resource.data.userId == request.auth.uid) &&
                      request.resource.data.keys().hasAll(['title', 'description']) &&
                      request.resource.data.status == 'pending' &&
                      request.resource.data.approvalStatus == 'pending';
      // Gig owner or admin can update
      allow update: if isAuthenticated() && (
        resource.data.freelancerId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // Gig owner or admin can delete
      allow delete: if isAuthenticated() && (
        resource.data.freelancerId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
    }

    // Blue Pages collection (business directory)
    // ADMIN APPROVAL WORKFLOW: All posts start as pending, only admins see pending, only approved visible to public
    match /blue_pages/{listingId} {
      // Read rules: Admins see all, non-admins see only approved OR own pending documents
      allow read: if isAuthenticated() && (
        isAdmin() ||
        resource.data.approvalStatus == 'approved' ||
        (resource.data.userId == request.auth.uid || resource.data.ownerId == request.auth.uid)
      );
      // Only companies can create listings and only when company monetization is enabled
      // All new listings start with approvalStatus='pending'
      // Code may use either 'userId' or 'ownerId' field for creator identification
      allow create: if isCompany() &&
                      (request.resource.data.userId == request.auth.uid ||
                       request.resource.data.ownerId == request.auth.uid) &&
                      request.resource.data.keys().hasAll(['description', 'approvalStatus']) &&
                      request.resource.data.approvalStatus == 'pending' &&
                      // Monetization toggle check
                      get(/databases/$(database)/documents/system/monetization).data.isCompanyMonetizationEnabled == true;
      // Listing owner or admin can update
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // Listing owner or admin can delete
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
    }

    // Tenders collection (tender opportunities)
    // ADMIN APPROVAL WORKFLOW: All posts start as pending, only admins see pending, only approved visible to public
    match /tenders/{tenderId} {
      // Read rules: Admins see all, non-admins see only approved OR own pending documents
      allow read: if isAuthenticated() && (
        isAdmin() ||
        resource.data.approvalStatus == 'approved' ||
        (resource.data.organizationId == request.auth.uid || resource.data.userId == request.auth.uid)
      );
      // ANY authenticated user can create tenders
      // All new tenders must include approvalStatus='pending'
      allow create: if isAuthenticated() &&
                      (request.resource.data.organizationId == request.auth.uid ||
                       request.resource.data.userId == request.auth.uid) &&
                      request.resource.data.keys().hasAll(['title', 'description', 'status', 'deadline', 'approvalStatus']) &&
                      request.resource.data.status == 'Open' &&
                      request.resource.data.approvalStatus == 'pending';
      // Tender owner or admin can update
      allow update: if isAuthenticated() && (
        resource.data.organizationId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // Tender owner or admin can delete
      allow delete: if isAuthenticated() && (
        resource.data.organizationId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      
      // Tender applications subcollection
      match /applications/{applicationId} {
        // Tender owner, applicant, or admin can read
        allow read: if isAuthenticated() && (
          resource.data.applicantId == request.auth.uid ||
          get(/databases/$(database)/documents/tenders/$(tenderId)).data.organizationId == request.auth.uid ||
          get(/databases/$(database)/documents/tenders/$(tenderId)).data.userId == request.auth.uid ||
          isAdmin()
        );
        // Authenticated users can apply to tenders (except their own)
        allow create: if isAuthenticated() &&
                        request.resource.data.applicantId == request.auth.uid &&
                        request.resource.data.keys().hasAll(['applicantId', 'status']) &&
                        request.resource.data.status == 'pending' &&
                        // Cannot apply to own tender
                        get(/databases/$(database)/documents/tenders/$(tenderId)).data.organizationId != request.auth.uid &&
                        get(/databases/$(database)/documents/tenders/$(tenderId)).data.userId != request.auth.uid;
        // Applicant or tender owner can update
        allow update: if isAuthenticated() && (
          resource.data.applicantId == request.auth.uid ||
          get(/databases/$(database)/documents/tenders/$(tenderId)).data.organizationId == request.auth.uid ||
          get(/databases/$(database)/documents/tenders/$(tenderId)).data.userId == request.auth.uid ||
          isAdmin()
        );
        // Applicant can delete their own application
        allow delete: if isAuthenticated() && (
          resource.data.applicantId == request.auth.uid ||
          isAdmin()
        );
      }
    }

    // API Keys collection (admin-only configuration)
    match /api_keys/{documentId} {
      // Anyone authenticated can read API keys (needed for app initialization)
      // Only admins can write/update API keys
      allow read: if isAuthenticated();
      allow write: if isAdmin();
    }

    // Youth Opportunities collection
    // ADMIN APPROVAL WORKFLOW: All posts start as pending, only admins see pending, only approved visible to public
    match /youth_opportunities/{opportunityId} {
      // Read rules: Admins see all, non-admins see only approved OR own pending documents
      allow read: if isAuthenticated() && (
        isAdmin() ||
        resource.data.approvalStatus == 'approved' ||
        (resource.data.organizationId == request.auth.uid || resource.data.userId == request.auth.uid)
      );
      // ANY authenticated user can create opportunities
      // All new opportunities must include approvalStatus='pending'
      // Code may use either 'userId' or 'organizationId' field for creator identification
      allow create: if isAuthenticated() &&
                      (request.resource.data.organizationId == request.auth.uid ||
                       request.resource.data.userId == request.auth.uid) &&
                      request.resource.data.keys().hasAll(['title', 'description', 'approvalStatus']) &&
                      request.resource.data.approvalStatus == 'pending';
      // Opportunity owner or admin can update
      allow update: if isAuthenticated() && (
        resource.data.organizationId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // Opportunity owner or admin can delete
      allow delete: if isAuthenticated() && (
        resource.data.organizationId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
    }

    // News collection
    // ADMIN APPROVAL WORKFLOW: All posts start as pending, only admins see pending, only approved visible to public
    match /news/{newsId} {
      // Read rules: Admins see all, non-admins see only approved OR own pending documents
      allow read: if isAuthenticated() && (
        isAdmin() ||
        resource.data.approvalStatus == 'approved' ||
        (resource.data.authorId == request.auth.uid || resource.data.userId == request.auth.uid)
      );
      // ANY authenticated user can create news
      // All new news items must include approvalStatus='pending'
      // Code may use either 'authorId' or 'userId' field for creator identification
      allow create: if isAuthenticated() &&
                      (request.resource.data.authorId == request.auth.uid ||
                       request.resource.data.userId == request.auth.uid) &&
                      request.resource.data.keys().hasAll(['title', 'content', 'approvalStatus']) &&
                      request.resource.data.approvalStatus == 'pending';
      // News author or admin can update
      allow update: if isAuthenticated() && (
        resource.data.authorId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // News author or admin can delete
      allow delete: if isAuthenticated() && (
        resource.data.authorId == request.auth.uid ||
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
    }

    // Hustles collection (quick job opportunities)
    // ADMIN APPROVAL WORKFLOW: All posts start as pending, only admins see pending, only approved visible to public
    match /hustles/{hustleId} {
      // Read rules: Admins see all, non-admins see only approved OR own pending documents
      allow read: if isAuthenticated() && (
        isAdmin() ||
        resource.data.approvalStatus == 'approved' ||
        (resource.data.userId == request.auth.uid || resource.data.postedBy == request.auth.uid)
      );
      // ANY authenticated user can create hustles
      // All new hustles must include approvalStatus='pending'
      // Code may use either 'userId' or 'postedBy' field for creator identification
      allow create: if isAuthenticated() &&
                      (request.resource.data.userId == request.auth.uid ||
                       request.resource.data.postedBy == request.auth.uid) &&
                      request.resource.data.keys().hasAll(['title', 'description', 'status', 'approvalStatus']) &&
                      request.resource.data.status == 'active' &&
                      request.resource.data.approvalStatus == 'pending';
      // Hustle owner or admin can update
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // Hustle owner or admin can delete
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
    }

    // Tender Applications collection
    match /tender_applications/{applicationId} {
      // Tender owner, applicant, or admin can read
      allow read: if isAuthenticated() && (
        resource.data.applicantId == request.auth.uid ||
        get(/databases/$(database)/documents/tenders/$(resource.data.tenderId)).data.organizationId == request.auth.uid ||
        isAdmin()
      );
      // Authenticated users can apply to tenders (except their own)
      allow create: if isAuthenticated() &&
                      request.resource.data.applicantId == request.auth.uid &&
                      request.resource.data.keys().hasAll(['tenderId', 'applicantId', 'status']) &&
                      request.resource.data.status == 'pending' &&
                      // Cannot apply to own tender
                      get(/databases/$(database)/documents/tenders/$(request.resource.data.tenderId)).data.organizationId != request.auth.uid;
      // Applicant or tender owner can update
      allow update: if isAuthenticated() && (
        resource.data.applicantId == request.auth.uid ||
        get(/databases/$(database)/documents/tenders/$(resource.data.tenderId)).data.organizationId == request.auth.uid ||
        isAdmin()
      );
      // Applicant can delete their own application
      allow delete: if isAuthenticated() && (
        resource.data.applicantId == request.auth.uid ||
        isAdmin()
      );
    }

    // Wallet Settings collection (monetization configuration)
    match /wallet_settings/{docId} {
      // Anyone authenticated can read settings
      allow read: if isAuthenticated();
      // Only admins can write settings
      allow write: if isAdmin();
    }

    // Plugins collection (dynamic plugin configuration)
    // ADMIN APPROVAL WORKFLOW: All posts start as pending, only admins see pending, only approved visible to public
    match /plugins/{pluginId} {
      // Read rules: Admins see all, non-admins see only approved OR own pending
      allow read: if isAuthenticated() && (
        isAdmin() ||
        resource.data.approvalStatus == 'approved' ||
        resource.data.userId == request.auth.uid
      );
      // Authenticated users can create plugin entries
      // All new plugins must include approvalStatus='pending'
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.keys().hasAll(['title', 'description', 'userId', 'approvalStatus']) &&
                      request.resource.data.approvalStatus == 'pending';
      // Owners can update their own plugin items (but cannot approve) and admins can manage/audit
      allow update: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
      allow delete: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
    }

    // App Settings collection (admin configuration for app features)
    match /app_settings/{settingId} {
      // Anyone authenticated can read settings (needed for app initialization)
      allow read: if isAuthenticated();
      // Only admins can write/update settings
      allow write: if isAdmin();
    }

    // Ratings collection (bidirectional: companies rate job seekers, job seekers rate companies)
    match /ratings/{ratingId} {
      // Read rules:
      // - Public (unauthenticated) and authenticated users can read approved ratings only
      // - Admins can read everything
      // - Original rater can read their own ratings (including pending)
      allow read: if resource.data.isApproved == true || isAdmin() || (isAuthenticated() && resource.data.raterId == request.auth.uid);
      
      // Authenticated users can create ratings if they meet all validation requirements
      // and the document id matches the deterministic pattern: raterId_ratedUserId_jobId
      allow create: if canCreateRating() && ratingId == (request.resource.data.raterId + '_' + request.resource.data.ratedUserId + '_' + request.resource.data.jobId);

      // Updates:
      // - Admins can update any field (approve, unflag, etc.)
      // - Original rater can only update their feedback text (no approval/flag toggles or rating changes)
      allow update: if isAdmin() || (
        isAuthenticated() &&
        resource.data.raterId == request.auth.uid &&
        // Ensure only feedback is modified by the rater (all other critical fields must remain equal)
        request.resource.data.raterId == resource.data.raterId &&
        request.resource.data.ratedUserId == resource.data.ratedUserId &&
        request.resource.data.jobId == resource.data.jobId &&
        request.resource.data.rating == resource.data.rating &&
        // Approval/flag status cannot be altered by rater
        ( ! (request.resource.data.keys().hasAny(['isApproved'])) || request.resource.data.isApproved == resource.data.isApproved ) &&
        ( ! (request.resource.data.keys().hasAny(['isFlagged'])) || request.resource.data.isFlagged == resource.data.isFlagged )
      );

      // Deletion allowed by admin or original rater
      allow delete: if isAdmin() || (isAuthenticated() && resource.data.raterId == request.auth.uid);
    }

    // Plugin Items collection (dynamic user content in plugin sections)
    // ADMIN APPROVAL WORKFLOW: All posts start as pending, only admins see pending, only approved visible to public
    // E.g., blue_pages, tenders, youth_opportunities items
    match /plugin_items/{itemId} {
      // Read rules: Admins see all, non-admins see only approved OR own pending documents
      allow read: if isAuthenticated() && (
        isAdmin() ||
        resource.data.approvalStatus == 'approved' ||
        resource.data.userId == request.auth.uid
      );
      // Authenticated users can create items
      // All new items must include approvalStatus='pending'
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.keys().hasAll(['title', 'description', 'userId', 'approvalStatus']) &&
                      request.resource.data.approvalStatus == 'pending';
      // Item owner or admin can update
      allow update: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
      // Item owner or admin can delete
      allow delete: if isAuthenticated() && (
        resource.data.userId == request.auth.uid ||
        isAdmin()
      );
    }

    // User Preferences collection (user-specific settings)
    match /user_preferences/{userId} {
      // Users can read and write their own preferences
      allow read, write: if isAuthenticated() && isOwner(userId);
      // Admins can read any user preferences (for debugging/support)
      allow read: if isAdmin();
    }

    // User suspension collection (admin-managed account suspensions)
    match /user_suspensions/{suspensionId} {
      // Only admins can read and manage suspensions
      allow read, write, delete: if isAdmin();
    }

    // Admin audit logs collection (admin actions tracking)
    match /admin_audit_logs/{logId} {
      // Only admins can read audit logs
      allow read: if isAdmin();
      // Only admins can create audit logs (typically from Cloud Functions)
      allow create: if isAdmin();
      // No updates or deletes allowed (immutable audit trail)
      allow update, delete: if false;
    }

    // Scheduled notifications collection
    match /scheduled_notifications/{notificationId} {
      // Users can read their own scheduled notifications
      allow read: if isAuthenticated() && 
                    (resource.data.userId == request.auth.uid || isAdmin());
      // Authenticated users can create scheduled notifications for themselves
      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid;
      // Users can update/delete their own notifications, admins can manage all
      allow update, delete: if isAuthenticated() && 
                              (resource.data.userId == request.auth.uid || isAdmin());
    }

    // Interviews collection - NEW for interview management system
    match /interviews/{interviewId} {
      // Employers can read interviews they created
      allow read: if isAuthenticated() && request.auth.uid == resource.data.employer_id;
      
      // Job seekers can read interviews where they are the candidate
      allow read: if isAuthenticated() && request.auth.uid == resource.data.candidate_id;
      
      // Only employers can create interviews
      allow create: if isAuthenticated() && 
                       request.auth.uid == request.resource.data.employer_id &&
                       request.resource.data.status == 'Scheduled' &&
                       request.resource.data.employer_id is string &&
                       request.resource.data.candidate_id is string &&
                       request.resource.data.scheduled_date is timestamp;
      
      // Employers can update their interviews (reschedule, cancel, etc)
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.employer_id &&
                       request.resource.data.status in ['Scheduled', 'Cancelled', 'Ongoing', 'Completed'];
      
      // Job seekers can update interviews to decline or mark as no-show
      allow update: if isAuthenticated() && 
                       request.auth.uid == resource.data.candidate_id &&
                       request.resource.data.status in ['Declined', 'No-Show'];
      
      // Only employers can delete interviews
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.employer_id;
    }

    // Interview prep sessions - Job seekers can track their interview prep progress
    match /interview_prep_sessions/{prepSessionId} {
      // Job seekers can read their own prep sessions
      allow read: if isAuthenticated() && request.auth.uid == resource.data.job_seeker_id;
      
      // Job seekers can create prep sessions for themselves
      allow create: if isAuthenticated() &&
                       request.auth.uid == request.resource.data.job_seeker_id &&
                       request.resource.data.interview_id is string;
      
      // Job seekers can update their prep sessions (add attempts, scores, etc)
      allow update: if isAuthenticated() && request.auth.uid == resource.data.job_seeker_id;
      
      // Job seekers can delete their prep sessions
      allow delete: if isAuthenticated() && request.auth.uid == resource.data.job_seeker_id;
    }

    // Compliance warnings collection (admin-managed user conduct warnings)
    match /compliance_warnings/{warningId} {
      // Admins can read all warnings
      allow read: if isAdmin();
      
      // Admins and automated service can create warnings (isAdmin() or automatedFlag=true)
      allow create: if isAdmin() ||
                       (request.resource.data.automatedFlag == true &&
                        request.resource.data.contentId != null &&
                        request.resource.data.contentType != null);
      
      // Only admins can update warning status
      allow update: if isAdmin();
      
      // Only admins can delete
      allow delete: if isAdmin();

      // Warning history subcollection (read-only for admins)
      match /history/{historyId} {
        allow read: if isAdmin();
        allow create, update: if isAdmin();
      }
    }

    // Disputes collection (user dispute management and resolution)
    match /disputes/{disputeId} {
      // Only admins can read disputes
      allow read: if isAdmin();
      
      // Only admins can create disputes (typically from user-facing dispute submission)
      allow create: if isAdmin();
      
      // Only admins can update dispute status and resolution
      allow update: if isAdmin();
      
      // Only admins can delete disputes
      allow delete: if isAdmin();

      // Messages subcollection (two-way messaging between users and admin)
      match /messages/{messageId} {
        // Only admins can read all messages
        allow read: if isAdmin();
        
        // Only admins can create messages (admin responses to disputes)
        allow create: if isAdmin() &&
                        request.resource.data.senderType == 'admin' &&
                        request.resource.data.senderId is string &&
                        request.resource.data.message is string &&
                        request.resource.data.createdAt is timestamp;
        
        // No updates or deletes allowed (immutable message history)
        allow update, delete: if false;
      }
    }

    // Admin Roles collection (role-based access control)
    match /admin_roles/{userId} {
      // Only super admins can read admin roles
      allow read: if isSuperAdmin();
      
      // Only super admins can create/update admin roles
      allow create, update: if isSuperAdmin() &&
                             request.resource.data.role in ['superAdmin', 'moderator', 'analyst', 'financial', 'support'] &&
                             request.resource.data.keys().hasAll(['role', 'permissions', 'assignedAt']);
      
      // Only super admins can delete roles
      allow delete: if isSuperAdmin();

      // Permissions subcollection (tracks what each role can do)
      match /permissions/{permissionId} {
        // Only super admins can read/write permissions
        allow read, write, delete: if isSuperAdmin();
      }
    }

    // Job Closure Requests collection
    // Handles closure requests for jobs with hired applicants (requires admin approval)
    match /job_closure_requests/{requestId} {
      // Employers can read their own closure requests
      allow read: if isAuthenticated() && 
                     (
                       resource.data.employerId == request.auth.uid ||
                       isAdmin()
                     );
      
      // Employers can create closure requests for their jobs
      allow create: if isAuthenticated() &&
                      isCompany() &&
                      isApprovedCompany() &&
                      request.resource.data.employerId == request.auth.uid &&
                      request.resource.data.keys().hasAll([
                        'jobId', 'employerId', 'jobTitle', 'closureReason',
                        'hiredApplicants', 'applicantsToNotify', 'status',
                        'createdAt', 'totalApplications'
                      ]) &&
                      request.resource.data.status == 'pending';
      
      // Admins can update status (approve/reject)
      allow update: if isAdmin() &&
                      (
                        request.resource.data.status in ['approved', 'rejected']
                      ) &&
                      resource.data.status == 'pending';
      
      // Only admins can delete
      allow delete: if isAdmin();
    }
  }
}
